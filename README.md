# Тестовое задание на позицию Junior Python Programmer (стажер)

## Задание 1

Реализация приведена в файле task1.py. Приведённая реализация, в отличие от изначальной, использует побитовую конъюнкцию.

**Плюсы и минусы**

Преимуществом реализации через конъюнкцию является тот факт, что эта операция выполняется быстрее на процессорном уровне (во всяком случае, в более низкоуровневых языках, таких как C/C++, для которых наиболее характерны такие решения). Однако поскольку в Python числа хранятся как объекты, на фоне операций с памятью экономия времени на самих вычислениях теряется. Более того, за счёт оптимизации для операций '/','\*' и '%' для малых чисел (как минимум в версиях 3.x) вариант с битовыми операциями в некоторых случаях может требовать даже больших ресурсов по времени. Среди потенциальных минусов такой реализации - снижение читаемости кода, особенно в более сложном контексте.

## Задание 2

Реализация приведена в файле task2.py. Первый класс представляет собой реализацию циклического буфера на массиве, второй - на связных списках.

Сравнение этих реализаций во многом сводится к перечислению преимуществ и недостатков списков над массивами. С одной стороны, списки позволяют при необходимости легко реализовать динамическое увеличение размера за O(1), тогда как для массивов потребуется O(n). Более того, пустые и не до конца заполненные списки не тратят память на отсутствующие элементы, тогда как массивы резервируют память заранее. Наконец, для массивов требуется обязательно смежная область памяти, которой может не оказаться в свободном доступе, особенно для большого массива, тогда как элементы списка могут храниться разрозненно. С другой стороны, на указатели списков расходуется дополнительная память, а постоянные операции с памятью замедляют взаимодействие с элементами списка. Кроме того, отсутствие доступа к произвольному элементу за O(1) снижает результативность кэширования и распараллеливания при вычислениях.

## Задание 3

Необходимо отметить, что наиболее быстрая сортировка может быть выявлена только в рамках задачи с конкретными данными известной структуры, иначе бы отпала потребность в большинстве актуальных алгоритмов и остался бы только один из них. Однако в рамках данного задания как одни из наиболее оптимальных мною выбраны два вида сортировки: сортировка слиянием и быстрая сортировка. Реализация приведена в файле task3.py. Оба алгорита имеют асимптотическую сложность $O(n \* log (n))$ в среднем.
Быстрая сортировка в худшем случае деградирует до сложности $O(xn^2)$, но на больших массивах работает быстрее и на них она считается в среднем самой быстрой из негибридных сортировок, основанных на сравнениях (при применении вслепую на данных стохастического характера). Именно поэтому именно она является основой для популярных гибридных алгоритмов (например, Introsort). В приведённой мной реализации в качестве опорного элемента используется серединный элемент массива, эту наивную тактику можно совершенствовать. Среди минусов такого решения можно назвать возможность переполнения стека при слишком большой вложенности рекурсии и неустойчивость алгоритма. Конечно, при необходимости работы с комплексными объектами можно использовать устойчивые модификации быстрой сортировки, однако тогда средняя сложность деградирует до $O(n \* log^2 (n))$, а худший случай до $O($n^2$ \* log(n))$.
Сортировка слиянием обладает сложностью $O(n \* log (n))$ даже в худшем случае, но она требует $O(n)$ дополнительной памяти и неадаптивна (не сокращает время работы для "почти отсортированных" массивов). Для устранения данного недостатка эту сортировку можно сочетать с другими, на этом в том числе основан алгоритм Timsort, лежащий в основе базовой сортировки Python. Среди преимуществ данной сортировки - устойчивость и стабильность вне зависимости от данных при оптимальнои среднем результате - именно поэтому она оказалась одним из выбранных вариантов.
Тем не менее многие другие алгоритмы также сохраняют свою применимость. Например, в Introsort используется сортировка кучей. Порой это касается даже медленных алгоритмов с $O(n^2)$ - так, метод сортировки вставками применяется в гибридном алгоритме Timsort, так как очень быстро работает на частично упорядоченных данных. Это ещё раз доказывает привязку подбора наиболее быстрого алгоритма к характеру конкретных данных и поставленной задаче.